#lec11: 进程／线程概念spoc练习

## 视频相关思考题

### 11.1 进程的概念

1. 什么是程序？什么是进程？

    - 程序：有序代码的集合
    - 进程：一个具有一定独立功能的程序在一个数据集合上一次动态执行的过程


2. 进程有哪些组成部分？

    - 代码
    - 数据
    - 状态寄存器
    - 通用寄存器
    - 进程占用的系统资源


3. 请举例说明进程的独立性和制约性的含义。

    - 独立性：进程可以被独立调度并占用处理机运行，不同的进程的工作不相互影响
    - 制约性：进程会因访问共享的数据/资源或进程间的同步而产生制约

4. 程序和进程联系和区别是什么？

    - 联系
        - 进程是操作系统处于执行状态程序的抽象
        - 同一个程序的多次执行过程对应于不同的进程
        - 进程执行需要内存保存代码和数据，以及CPU执行指令

    - 区别
        - 进程是动态的，程序是静态的
        - 进程是暂时的，程序是永久的
        - 进程包括程序，数据和进程控制块


### 11.2 进程控制块

1. 进程控制块的功能是什么？

    - 进程创建
    - 进程终止
    - 进程的组织管理

2. 进程控制块中包括什么信息？

    - 调度和状态信息：调度进程和处理机使用情况
    - 进程间通信信息：进程间通信相关的各种标识
    - 存储管理信息：指向进程映像存储空间数据结构
    - 进程所用资源：进程使用的系统资源如文件等
    - 有关数据结构的链接信息：与PCB相关的进程队列

3. ucore的进展控制块数据结构定义中哪些字段？有什么作用？

    - PC：指向当前程序执行代码
    - SP：指向当前栈顶位置
    - 其他寄存器
    - PID
    - UID
    - 调度优先级
    - 打开文件列表

### 11.3 进程状态

1. 进程生命周期中的相关事件有些什么？它们对应的进程状态变化是什么？

    - 创建：创建->就绪
    - 执行：就绪->运行
    - 等待：运行->等待
    - 抢占：运行->就绪
    - 唤醒：等待->就绪
    - 结束：运行->退出


### 11.4 三状态进程模型

1. 运行、就绪和等待三种状态的含义？7个状态转换事件的触发条件是什么？

    - 就绪：进程已分配到除CPU以外所有必要的资源，只要获得处理机便可立即执行。
    - 执行：进程已经获得处理机，其程序正在处理机上执行
    - 等待：正在执行的进程因为等待某个事件发生而无法执行，放弃处理机

    触发条件：

    - NULL->创建：一个新进程被产生出来执行一个程序
    - 创建->就绪：进程创建完成并初始化，一切就绪准备运行
    - 就绪->运行：就绪进程被进程调度程序选中后分配到处理机上来运行
    - 运行->结束：运行进程表示完成或出错
    - 运行->就绪：运行进程由于分配的时间片用完而让出处理机
    - 运行->等待：进程请求某些资源而必须等待
    - 等待->就绪：进程等待的事件到来


### 11.5 挂起进程模型

1. 引入挂起状态的目的是什么？

    减少进程占用的内存。

2. 引入挂起状态后，状态转换事件和触发条件有什么变化？

    新增了等待挂起和就绪挂起的状态。创建后可以直接进入就绪挂起状态，在就绪，运行等状态也可以进入就绪挂起状态。等待可以进入等待挂起状态，就绪挂起和等待挂起在激活后分别进入就绪和等待状态，等待挂起如果等到了相应的事件发生，则进入就绪挂起。

3. 内存中的什么内容放到外存中，就算是挂起状态？

    挂起指的是把一个进程从内存转到外存。

### 11.6 线程的概念

1. 引入线程的目的是什么？

    在线程内部新增的一类轻量级的实体，在实体之间能够并发执行，并共享相同的地址空间。

2. 什么是线程？

    线程是进程的一部分，描述指令流执行状态，是进程中指令执行流的最小单元，是CPU调度的最小基本单元。

3. 进程与线程的联系和区别是什么？

    - 进程是资源分配单位，线程是CPU调度单位
    - 进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源
    - 线程也具有就绪等待和运行三种基本状态和转换关系
    - 线程能够减小并发执行时间和空间开销
 
### 11.7 用户线程

1. 什么是用户线程？

    在用户空间实现的线程。

2. 用户线程的线程控制块保存在用户地址空间还是在内核地址空间？

    用户地址空间。


### 11.8 内核线程

1. 用户线程与内核线程的区别是什么？

    - 内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。
    - 用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。
    - 用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。
    - 在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。
    - 用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。

2. 同一进程内的不同线程可以共用一个相同的内核栈吗？

3. 同一进程内的不同线程可以共用一个相同的用户栈吗？


## 选做题
1. 请尝试描述用户线程堆栈的可能维护方法。

## 小组思考题
(1) 熟悉和理解下面的简化进程管理系统中的进程状态变化情况。
 - [简化的三状态进程管理子系统使用帮助](https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep7-process-run.md)
 - [简化的三状态进程管理子系统实现脚本](https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep7-process-run.py)

(2) (spoc)设计一个简化的进程管理子系统，可以管理并调度如下简化进程。在理解[参考代码](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab4/process-concept-homework.py)的基础上，完成＂YOUR CODE"部分的内容。然后通过测试用例和比较自己的实现与往届同学的结果，评价自己的实现是否正确。可２个人一组。

### 进程的状态 

 - RUNNING - 进程正在使用CPU
 - READY   - 进程可使用CPU
 - DONE    - 进程结束

### 进程的行为
 - 使用CPU, 
 - 发出YIELD请求,放弃使用CPU


### 进程调度
 - 使用FIFO/FCFS：先来先服务,
   - 先查找位于proc_info队列的curr_proc元素(当前进程)之后的进程(curr_proc+1..end)是否处于READY态，
   - 再查找位于proc_info队列的curr_proc元素(当前进程)之前的进程(begin..curr_proc-1)是否处于READY态
   - 如都没有，继续执行curr_proc直到结束

### 关键模拟变量
 - 进程控制块
```
PROC_CODE = 'code_'
PROC_PC = 'pc_'
PROC_ID = 'pid_'
PROC_STATE = 'proc_state_'
```
 - 当前进程 curr_proc 
 - 进程列表：proc_info是就绪进程的队列（list），
 - 在命令行（如下所示）需要说明每进程的行为特征：（１）使用CPU ;(2)等待I/O
```
   -l PROCESS_LIST, --processlist= X1:Y1,X2:Y2,...
   X 是进程的执行指令数; 
   Ｙ是执行CPU的比例(0..100) ，如果是100，表示不会发出yield操作
```
 - 进程切换行为：系统决定何时(when)切换进程:进程结束或进程发出yield请求

### 进程执行
```
instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)
```

### 关键函数
 - 系统执行过程：run
 - 执行状态切换函数:　move_to_ready/running/done　
 - 调度函数：next_proc

### 执行实例

#### 例１
```
$./process-simulation.py -l 5:50
Process 0
  yld
  yld
  cpu
  cpu
  yld

Important behaviors:
  System will switch when the current process is FINISHED or ISSUES AN YIELD
Time     PID: 0 
  1     RUN:yld 
  2     RUN:yld 
  3     RUN:cpu 
  4     RUN:cpu 
  5     RUN:yld 

```

   
#### 例２
```
$./process-simulation.py  -l 5:50,5:50
Produce a trace of what would happen when you run these processes:
Process 0
  yld
  yld
  cpu
  cpu
  yld

Process 1
  cpu
  yld
  cpu
  cpu
  yld

Important behaviors:
  System will switch when the current process is FINISHED or ISSUES AN YIELD
Time     PID: 0     PID: 1 
  1     RUN:yld      READY 
  2       READY    RUN:cpu 
  3       READY    RUN:yld 
  4     RUN:yld      READY 
  5       READY    RUN:cpu 
  6       READY    RUN:cpu 
  7       READY    RUN:yld 
  8     RUN:cpu      READY 
  9     RUN:cpu      READY 
 10     RUN:yld      READY 
 11     RUNNING       DONE 
```
