# lec6 SPOC思考题


NOTICE
- 有"w3l2"标记的题是助教要提交到学堂在线上的。
- 有"w3l2"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。

## 与视频相关思考题

### 6.1	非连续内存分配的需求背景
 1. 为什么要设计非连续内存分配机制？

    连续分配内存存在外碎片和内碎片，动态修改内存分配也比较困难，内存利用率低下。设计非连续内存分配机制的目的在于允许程序使用非连续的物理地址空间，允许共享代码和数据，支持动态加载和动态链接，提高内存的利用效率和管理的灵活性。

 1. 非连续内存分配中内存分块大小有哪些可能的选择？大小与大小是否可变?

    大块好管理，小块更灵活。段式存储下，大小是可变的，且块比较大。页式存储下，大小是固定的，且块比较小。

 1. 为什么在大块时要设计大小可变，而在小块时要设计成固定大小？小块时的固定大小可以提供多种选择吗？

    固定大小好管理，多种大小比一种大小灵活。可变大小更灵活，通常可变大小也会通过对齐来减少管理难度。小块时如果大小可变，则提供的灵活性没有那么多。

### 6.2	段式存储管理
 1. 什么是段、段基址和段内偏移？

    - 段表示访问方式和存储数据等属性相同的一段地址空间。
    - 段基址是描述段的位置的属性，存储在同一个段内的数据的段基址是相同的。通常构成逻辑地址的高若干位，表示该段所在的逻辑地址区间范围。
    - 段内偏移是描述具体逻辑地址位置的量。通常构成逻辑地址的低若干位，表示地址在段基址的基础上偏移了多少的地址空间。

 1. 段式存储管理机制的地址转换流程是什么？为什么在段式存储管理中，各段的存储位置可以不连续？这种做法有什么好处和麻烦？

    - CPU获取逻辑地址，并将其分为段号和段偏移两部分。
    - 在段表中查找对应段号的基址和长度，存入段基址寄存器和段长度寄存器。
    - 比较段偏移量寄存器和段长度寄存器的值，判断是否发生的访问越界。
    - 若发生越界，则报告内存异常。若正常则将段偏移和段基址寄存器相加得到对应的物理地址。
    - 在内存中进行寻址访问。

    在此时各段存储位置可以不连续的原因是通过段表这样的结构，可以方便地记录不连续的若干段的访问信息，而逻辑地址中可以通过段号进行查表，快速找到段基址和段长度。

    优点在与能够更加灵活高效地分配内存空间。缺点在于需要操作系统保持对于段表的设置维护和更新。实现更为繁琐。

### 6.3	页式存储管理
 1. 什么是页（page）、帧（frame）、页表（page table）、存储管理单元（MMU）、快表（TLB, Translation Lookaside Buffer）和高速缓存（cache）？

    - 页：将逻辑地址空间划分为的一定大小的基本分配单位。
    - 帧：将物理地址空间划分为的一定大小的基本分配单位。帧与页的大小相同。
    - 页表：用于存放逻辑地址与物理地址之间的映射关系。
    - MMU：用于管理虚拟存储器和物理存储器的控制线路，也负责虚拟地址映射为物理地址。
    - TLB：用于缓存近期访问的页表项，能够快速获取一些常用到的页表项。

 1. 页式存储管理机制的地址转换流程是什么？为什么在页式存储管理中，各页的存储位置可以不连续？这种做法有什么好处和麻烦？

    - CPU获取逻辑地址，将其拆分为页号和页内偏移。
    - 在页表中按照页号可以查找到对应的帧号。
    - 将帧号和页内偏移合并，得到物理地址。
    - 按照物理地址在内存内进行访问。

    这里可以各页的存储位置可以不连续的原因在于通过页表建立了从逻辑地址到物理地址的映射。可以通过查表的方式获取其在物理地址空间中的位置。

    优点是进程之间不需要考虑到内存分配的问题，只需要在自己的虚拟内存空间中进行内存的分配和处理，将其到物理地址的映射工作交给操作系统。缺点是访问一个内存单元需要2次内存访问，性能较低，同时存储页表需要较大的空间。

### 6.4	页表概述
 1. 每个页表项有些什么内容？有哪些标志位？它们起什么作用？

    页表项包含标志位和帧号。标志位具体包括：

    - 存在位：表示在这一项是否存在有效的项
    - 修改位：表示这一页表项是否被修改过
    - 引用位：表示这一页表项是否被引用

 1. 页表大小受哪些因素影响？

    页大小和页的数量。

### 6.5	快表和多级页表
 1. 快表（TLB）与高速缓存（cache）有什么不同？

    TLB是页表的子集，记录的是逻辑地址到物理地址的映射信息。Cache是内存的子集，记录的是内存中的数据。

 1. 为什么快表中查找物理地址的速度非常快？它是如何实现的？为什么它的的容量很小？

    TLB通过硬件电路能够实现快速访问的性能，命中可以立即输出目的物理地址。TLB使用关联存储实现，具备快速访问性能。若要增大TLB的容量，其访问的速度势必会受到影响，为了保证TLB能够高速地进行访问，它的容量通常不会太大。

 1. 什么是多级页表？多级页表中的地址转换流程是什么？多级页表有什么好处和麻烦？

    多级页表指的是通过树状的结构构造页表。使得页表分为多个层级，通过上一层的页表对下一层的页表进行索引。
    在转换时，将逻辑地址分为多级页表的一系列索引项和最后的偏移量，在第一级页表中，通过第一级页表在逻辑地址中的索引项，可以查找到第二级页表的位置，之后级别的页表均根据上一级得到的页表位置，以及逻辑地址中的这一级页表索引，获取到下一级页表的位置，直到最后查到物理地址。
    好处是减少了每级页表的长度，但是增大了实现和维护的成本。

### 6.6	反置页表
 1. 页寄存器机制的地址转换流程是什么？

    - 对逻辑地址进行Hash
    - 在TLB中查找相应项
    - 有冲突存在时，遍历冲突项列表
    - 查找失败时产生异常

 1. 反置页表机制的地址转换流程是什么？

    - 逻辑地址中得到页号
    - 根据页号和PID计算出Hash
    - 在反置页表中查找对应的页表项，核对页号是否一致
    - 若没问题则找出对应的物理帧号，否则处理Hash冲突

 1. 反置页表项有些什么内容？

    包括PID，逻辑页号，标志位

### 6.7	段页式存储管理
 1. 段页式存储管理机制的地址转换流程是什么？这种做法有什么好处和麻烦？

    - 用段的机制将逻辑地址翻译为线性地址。
    - 用页的机制将线性地址翻译为物理地址。

    好处是保有了段式存储在内存保护方面，以及页式存储在内存利用和优化转移到后备存储两方面的优势。

    坏处是地址访问的过程更加复杂，开销更大。

 1. 如何实现基于段式存储管理的内存共享？

    将需要重用的内存映射到不同的段内。

 1. 如何实现基于页式存储管理的内存共享？

    将不同的页表项指向相同的物理页。

## 个人思考题
（1） (w3l2) 请简要分析64bit CPU体系结构下的分页机制是如何实现的



## 小组思考题
（1）(spoc) 某系统使用请求分页存储管理，若页在内存中，满足一个内存请求需要150ns (10^-9s)。若缺页率是10%，为使有效访问时间达到0.5us(10^-6s),求不在内存的页面的平均访问时间。请给出计算步骤。



（2）(spoc) 有一台假想的计算机，页大小（page size）为32 Bytes，支持32KB的虚拟地址空间（virtual address space）,有4KB的物理内存空间（physical memory），采用二级页表，一个页目录项（page directory entry ，PDE）大小为1 Byte,一个页表项（page-table entries
PTEs）大小为1 Byte，1个页目录表大小为32 Bytes，1个页表大小为32 Bytes。页目录基址寄存器（page directory base register，PDBR）保存了页目录表的物理地址（按页对齐）。

PTE格式（8 bit） :
```
  VALID | PFN6 ... PFN0
```
PDE格式（8 bit） :
```
  VALID | PT6 ... PT0
```
其
```
VALID==1表示，表示映射存在；VALID==0表示，表示映射不存在。
PFN6..0:页帧号
PT6..0:页表的物理基址>>5
```
在[物理内存模拟数据文件](./03-2-spoc-testdata.md)中，给出了4KB物理内存空间的值，请回答下列虚地址是否有合法对应的物理内存，请给出对应的pde index, pde contents, pte index, pte contents。
```
1) Virtual Address 6c74
   Virtual Address 6b22
2) Virtual Address 03df
   Virtual Address 69dc
3) Virtual Address 317a
   Virtual Address 4546
4) Virtual Address 2c03
   Virtual Address 7fd7
5) Virtual Address 390e
   Virtual Address 748b
```

比如答案可以如下表示： (注意：下面的结果是错的，你需要关注的是如何表示)
```
Virtual Address 7570:
  --> pde index:0x1d  pde contents:(valid 1, pfn 0x33)
    --> pte index:0xb  pte contents:(valid 0, pfn 0x7f)
      --> Fault (page table entry not valid)

Virtual Address 21e1:
  --> pde index:0x8  pde contents:(valid 0, pfn 0x7f)
      --> Fault (page directory entry not valid)

Virtual Address 7268:
  --> pde index:0x1c  pde contents:(valid 1, pfn 0x5e)
    --> pte index:0x13  pte contents:(valid 1, pfn 0x65)
      --> Translates to Physical Address 0xca8 --> Value: 16
```

[链接](https://piazza.com/class/i5j09fnsl7k5x0?cid=664)有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，请说明原因。

（3）请基于你对原理课二级页表的理解，并参考Lab2建页表的过程，设计一个应用程序（可基于python、ruby、C、C++、LISP、JavaScript等）可模拟实现(2)题中描述的抽象OS，可正确完成二级页表转换。

[链接](https://piazza.com/class/i5j09fnsl7k5x0?cid=664)有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，提交你的实现，并说明区别。

（4）假设你有一台支持[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)的机器，请问你如何设计操作系统支持这种类型计算机？请给出设计方案。

 (5)[X86的页面结构](http://os.cs.tsinghua.edu.cn/oscourse/OS2019spring/lecture06)
---

## 扩展思考题

阅读64bit IBM Powerpc CPU架构是如何实现[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)，给出分析报告。


## interactive　understand VM

[Virtual Memory with 256 Bytes of RAM](http://blog.robertelder.org/virtual-memory-with-256-bytes-of-ram/)：这是一个只有256字节内存的一个极小计算机系统。按作者的[特征描述](https://github.com/RobertElderSoftware/recc#what-can-this-project-do)，它具备如下的功能。
 - CPU的实现代码不多于500行；
 - 支持14条指令、进程切换、虚拟存储和中断；
 - 用C实现了一个小的操作系统微内核可以在这个CPU上正常运行；
 - 实现了一个ANSI C89编译器，可生成在该CPU上运行代码；
 - 该编译器支持链接功能；
 - 用C89, Python, Java, Javascript这4种语言实现了该CPU的模拟器；
 - 支持交叉编译；
 - 所有这些只依赖标准C库。
 
针对op-cpu的特征描述，请同学们通过代码阅读和执行对自己有兴趣的部分进行分析，给出你的分析结果和评价。
